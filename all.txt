=== What is Imperatrix Mundi

I use the name Imperatrix Mundi for a programming language I am trying to define
and prototype.  My ideas about the details change from time to time.

=== Goals

Any operations that look stylistically imperative, shall lead to an explanatory
story in declarative terms.  Those terms may include concurrent-constraint logic
and/or a purely functional component.

Any operations that look stylistically like concurrent constraint logic, shall
lead to an explanatory story in terms of two parts:

- a purely functional component,

+ a supply of Burton/Lennart "oracles", to explain the origin of don't-care
  nondeterminism.  This supply is passed in as an argument from the runtime
  environment.  It may come from a local environment, in such a way that code
  executing in different localities works with different supplies of oracles.

=== Integrated Programming Environment

Interaction will take place between an owner/programmer (a role, for now at
least, to be thought of as to be filled by a human being) and a mutable
computing construct that I will call a _programming node_.  The purpose of this
interaction is to allow the person to build up and exercise software.

A programming node will include a persistent store.  In a way, it might be
said to reside in the store.  However, the programming node will be executed
by a server process of some sort, that will carry out the interactions with the
human owner/programmer.  Somehow the store will be made to evolve so as to
track the interactions with the programmer/tester and exhibit new logical
state in accordance with the semantics of the language and of the IDE.

The state of a programming node in interaction with the human
owner/programmer/tester may be divided into two parts: a programming
subenvironment and a testing subenvironment.

The programming environment allows to define and modify some programming
artifacts and/or engineering artifacts.  These include some class-like
objects, which live in some hierarchic namespace.

The testing environment will execute the programs supplied from the programming
environment.  At any given moment, the testing environment can reflect the
state of an interaction with the tester-person (who is likely also the
programmer-person, but here I emphasize the testing role).  This state should
be persited.  It might not be persisted instantly; however, the language
semantics should make clear a notion of transaction, and in cases where the
order of transactions would matter for predicting future outputs of the system,
the transactions must be persisted in the same order that they happen in the
volatile environment.  The persisted state should never fall more than ten
minutes behind the volatile state.  When the computer along with the
physical mechanism of the persistent store and the path leading to it are idle,
the system should progress toward persisting more and more recent sate until
it is all saved or some of the physical components become engaged in
higher-priority interactions.

Programming artifacts (e. g. class-like objects defined in the programming
environment) will have a runtime aspect, which will be, in each case, an object
visible from the testing environment.  Even though a programming artifact can
be changed from time to time by the programmer, and therefore, amounts to a
mutable object on at least one timeline (the programming timeline), the
runtime manifestation of that prgramming object may look like a constant
according to the syntax and semantics of the language.  In that case, there have
to be some rules or procedures for schema evolution.  The state of the testing
environment probably ought to be analyzable consistent with some story about its
possible past, even if that story is a lie.  However, for a time interval ending
at the time for which we contemplate the story, and containing no programming
changes, there will be no lie.  The evolution of the runtime (i. e. testing)
environment through such a time interval must conform to the semantics of the
language.

=== Categories of Object By Topology 

An object in the runtime environment may be _copyable_ or _linear_.

I may harbor a seed of a concept of an _anticopyable_ object, but am not yet
sure that it can or should be defined.

=== Origin of an Object

An object can originate by someone invoking a class, so as to ask the class to
create and return an instance of itself.  There may be arguments to such an
invocation.  Those may provide flows that travel in the object, or some
derivitives of which would.

An object that is an instance of a class might have an internal aspect and an
external aspect.  The internal aspect will not be visible to clients outside
the object, but will serve the methods that operate on behalf of the object.

The classes defined in the programming environment should support some kind of
inheritance and mixins.

=== Copyable Objects

A copyable object represents a mathematical function or value.  Copyable objects
may be copied, in which case, each copy behaves precisely as the original.
Copyable objects may be destroyed without consequence.  Destroying an object is
exactly the same thing as making zero copies of it.

The data in copyable objects are dynamically typed in the sense of their
possible shape and in the sense of the messages they understand when invoked
as objects themselves.  However, they are statically typed in the sense that
they must all be copyable.

Whenever a copyable object is expected, it is possible to receive an object
denoting an exception or error instead.  For example, the numbers 0 and 6
are copyable objects.  Trying to divide 6 by 0 amounts to invoking 6 with a
"/" request with 0 as an argument.  6 reacts to this request by trying to
divide itself by zero.  Since this is mathematically impossible, the result
will be an exception indication.  An exception indication is itself a copyable
object.

A class of copyable object can be defined, such that if a client tries to
invoke an operation on the object by a name that the object does not understand,
the result(s) will be a "does not understand" exception.

It should also be possible to define a class of copyable object that exhibits
some sort of default behavior in case invoked with a selector that it does
not understand.  [TODO -- consider the case that the not-understood message
includes linear flows; how to prevent such a case from happening, or give
the semantics of what to do if it does happen.]

Exceptions should include metaprogramming information designed to help with
debugging, e. g., an identification of the line of source code where the
exception arose, the equivalent of a traceback, etc.

=== Linear Objects

A linear object has one origin and one fate.  It must be consumed exactly once.
It does not participate in any interactions along the way.  To make sure that
a linear object always understands the invocation that consumes it, it is
necessary to make sure they are all statically typed.  Therefore, the
programming environment must support a library of types of linear object.
Types, like classes defined in the programming environment, should live in an
hierarchic namespace.  Each type defines the complete set of signatures to which
any invocation of a linear object conforming to that type must itself conform to
one of those signatures.  More than one class of linear object can conform to
the same type.  Such classes can give rise to linear objects that exhibit
different behaviors, perhaps designed to support different sets of mathematical
invariants.  But since they conform to the same type, they will have the same
sets of possible signatues of the operations that consume them.

The contents of a linear object can themselves be either linear or copyable.
In the case of linear contents, they connect the origin with each possible
termination.  That is, each method has to deal with every linear flow in the
object either by returning it to the method caller or by invoking an operation
on it.

=== Lazy Evaluation

All functions are nonstrict in their arguments.

=== Supplies of Oracles

A supply of oracles is an object, but it might not conform fully to either of
the descriptions above of "linear" objects nor "copyable" objects.

The "class" of supplies of oracles might be wholly built in to the language,
and not extensible or redefinable in any way by coding.  In this regard it
should differ from the class of integers for example -- it would be reasonable
to say that for some region of code, extentions to the integer class could be
in effect.

A supply of oracles can always be dropped on the floor (i. e. destroyed).

For the time being, I exclude the possibility to copy a supply of oracles.

That exclusion will probably be permanent.  (Logically, it would be possible
to introduce a kind of asymmetric copying operation where one copy would
only be queryable and the other would be the only one capable of the oracular
operations to be described below.  However, I know of no particular reason to
support such an operation.)

So, a supply of oracles is like a copyable object in that it can be destroyed,
but unlike a copyable object in that we cannot make two or more copies.

A supply of oracles can always be split into two supplies of oracles.  This
involves three objects: the original supply that we start with, and the two
(or more)
supplies that result from the split.  The supplies that result have no
dependency on each other.  They came, conceptually, from different subsets of
the original supply.  They are as capable as it is, of supplying oracles for
new oracular operations, but they are not mathematically equal to the original.

For operations that an oracle can perform (and I am trying to sneak up on a
description of those operations), there is no need to isolate, in terms of the
flows described in the language (arguments and results), an oracle as a
separate object from a supply of oracles.  If we invoke an operation that I
descrbe as applicable to an oracle, on a supply of oracles, we can just tell
the story that we are dropping the oracles on the floor except for the one
we are using for the operation.

The Fudgets paper describes what I am calling a supply of oracles, as a tree of
oracles.  If any ambiguity arrises about which oracle is which in a supply
of oracles, we can tell the story that a supply of oracles is, mathematically,
a tree of oracles.  Of course, the tree is infinite, its subtrees are infinite,
and so on (specifically, the cardinality is aleph null).

Suppose we have two flows (parameters or results) of copyable objects.  Then
an oracle can tell us which of those gets reduced to a concrete value (a known
specific object) before the other.  This operation consumes the oracle.

=== Problems With These Definitions

I am trying to tell a story that will explain some concurrent constraint
programming in terms of functional programming plus oracles.  My intent with
the definitions so far is to define the components in which such a story could
be told.  However, I think I see trouble coming in regard to how to deal with
messages, when they could have linear flows in them.  That makes the messages
linear themselves.  Can we make a collection (a bag, or a list) of linear
objects?  Because a concurrent constraint process needs to be supplied such a
bag or list of commands it should execute in order to evolve itself and supply
services to its clients.

Maybe there is no problem, as a message (sorry I haven't told you what a message
is yet) could be regarded as declaring itself, by its signature, to be either
a copyable object or a linear one.

=== What Is The Abstract Syntax of a Method?

A class contains a collection of methods or equivalently rules.

A given rule includes a signature or head, and a body or tail.  The body or
tail includes some number of conclusions.  The order of the conclusions does
not matter.  A conclusion takes the form of an invocation.

The signature includes one word that should give the most key concept to its
intended meaning.  I have been mentally calling this word the "verb", but I
suspect that for good software-engineering practice, it might more often be
a noun.  For now, let's call it the "head name" of the operation.

The signature also includes any number of keyword-parameter pairs.

Each keyword-parameter pair includes, conceptually, a keyword, however, that
keyword may be the zero-length name.

The parameter in a keyword-parameter pair signifies a flow that can be referenced
in the body; moreover, there is type or mode information in the source code
accompanying the keyword-parameter pair.

When some client (another method) invokes an operation on an object, such that
the system can find the appropriate rule to fire to handle the operation, the
rule fires, and the parameters in the head of the rule are bound to the
arguments passed in from the invocation site.

When the argument carries information into the firing from the call, then from
the point of view of the method definition, we regard the information as rising,
or coming up, for purposes of declaring the mode of the keyword-parameter pair,
in the signature of the rule.

Conversely, when information goes in the opposite direction, then from the
viewpoint of the rule, it is sinking, or going down.

The rising and sinking concepts apply to flows that carry copyable objects.
They also apply to flows carrying oracle supplies in either direction.

If the binding of a parameter to an argument carries a linear object, then
the information inside the linear object may be sinking or rising, but formally,
we do not say the linear object is sinking or rising.  Ultimately, the
linear object binds the arguments of the call that created the object, to those
of the call that destroys it.

So we seem to arrive at an exhaustive list of possible modes for a parameter
(and these modes must be evident in the syntax of a rule head, and in the
syntax of a call, correspondingly):

- Linear flow, or
- Rising copyable, or
- Sinking copyable, or
- Rising oracle supply, or
- Sinking oracle supply.

We shall have eventually to invent concrete syntax to distinguish these cases.

Given the statements I've made heretofore, I infer the necessity to include,
in the case of linear flows, the statically defined type.

For a call to match a method, the modes must correspond (the rising/sinking
direction would be opposite).

The same head name with different keywords and/or different modes associated
to the keywords, still constitutes a different signature.  The methods in a
class must all have different signatures, and they may have the same head name
if the signatures differ otherwise.

The full "selector" being cited in a call amounts to the head name, the keywords
(order does not matter for the keywords; we can think, if necessary, of a
cannonical order for them as being alphabetical), and the modes associated to
the keywords.  Keywords cannot be repeated in a rule head or in a call.

The syntax of a call or invocation includes an expression for the object that
is to receive the call, plus all the components found in the syntax of a rule
head.  The object that is to receive the call is syntactically marked as to
its mode, from the above list.  If the receiver is rising, we are invoking it
and asking it to look for a rule within itself (or its classes, mixins, parents
or whatever, as determined by the inheritance system) matching the given head
word and keyword-argument pairs (directions reversed).  If the receiver is
declared as sinking, we are creating an object that encapsulates the arguments
and their modes.

Arguments are expressions.  Modal declarations accompany them syntactically,
along with the keywords.  When an argument is copyable or an oracle supply,
we declare it sinking if the information is flowing from the present context
toward the receiver of the message.  Conversely, for information flow in the
other direction, we declare it rising.

Although it may be convenient to provide syntactic sugaring with more complex
expressions, the fundamental expression is just an indication of where else in
the method (in terms of arguments and parameters) we are connecting the flow.
In the case of copyable objects, there
can be one source and any count of sinks.  In the case of linear objects, there
must be exactly one source and one sink.  In the case of splitting a supply of
oracles, there should be a primitive syntax to denote that.  Actually, it can
just take the form of a call on a rising supply of oracles, with a signature
fixed by the language.

=== Can I Move Forward From Here?

The above definitions are intended to define the functional language, and also
to provide enough power to explain the operation of the concurrent-constraint
langauge.  I am still not sure whether it is powerful enough.  Before trying
to write the explanation of one paradigm in terms of the other, let's lay out
the requiremnts for the concurrent-constraint language.

=== What Must Be Possible For The Concurrent-Constraint Language

The ToonTalk language provides an adequate model, for a first try, of a
concurrent-constraint language of roughly the sort for which I'm aiming.
To make an andequate langauge to use for addressing applications, I might want
to tweak some of ToonTalk's characteristics.  However, such tweakage should
not make a fundamental change in the level of capability from the viewpoint
of asking whether the primitive langauge I defined above makes up the sufficient
building blocks for implementing the concurrent-constraint language.

In fact, as I go along, I can make some tweaks, not for aiming toward a
practical language yet, but just toward having less work to do in telling the
story of how the langugage defined above (functional part plus oracles) can
implement the concurrent-constraint (CC) language.

=== Try To Explain CC In Terms of Func+Oracles

Consider a bird-nest pair in ToonTalk.  For the moment, suppose we neither
split the bird nor the nest.  What is this pair then, in terms of my primitives?
It wants to be a list of messages.  I can for sure make a list (Lisp-style) of
copyable values.  But what if I want to send a nest in the list?  How to
implement a nest?

Stuck.

